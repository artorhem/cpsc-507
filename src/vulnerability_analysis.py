from findimports import find_imports
import pip
import re, sys, os
import ast
from collections import namedtuple
import call_collector
from vulnerabilities import VulnerabilityDB
import fileinput

ImportedModule = namedtuple("ImportedModule", ["module", "name", "alias", "line", "column", "code"])
Vulnerability = namedtuple("Vulnerability", ["name", "file", "line", "column", "update", "reason", "import_location", "end", "code", "severity"])


class VulnerabilityAnalyzer:
    def __init__(self, path):
        """
        Constructor
        @param path: path to project to be analyzed
        """
        self.path = path
        self.detected_vulnerable_functions = []
        self.detected_vulnerable_imports = []
        self.detected_vulnerable_installed_dependencies = []
        self.outdated_dependencies = []

    def analyze(self):
        """
        Starts the analysis for vulnerable functions and
        vulnerable dependencies.
        """
        self.__detect_vulnerable_imports()
        self.__detect_vulnerable_functions()
        self.__get_code_context_for_vulnerabilities()
        self.__detect_vulnerable_installed_dependencies()

    def __get_dependencies(self):
        """
        Retrieves all dependencies from the projects located at `path`
        :return: list of dependencies
        """
        all_symnames = set()
        for root, dirs, files in os.walk(self.path):
            for file in files:
                # only analyze python files
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    all_symnames.update(x.name.split('.')[0] for x in find_imports(file_path))

        return all_symnames

    def __detect_vulnerable_imports(self):
        """
        Check for vulnerable imports in source code.
        """
        all_dependencies = self.__get_dependencies()

        # static analysis: only look in code
        for dependency in all_dependencies:
            dependency_name = dependency.split('.')[0]

            if VulnerabilityDB().get_vulnerable_dependency(dependency_name):
                vulnerable_dependency = {
                    'name': dependency_name,
                    'info': VulnerabilityDB().get_vulnerable_dependency(dependency_name)
                }

                self.detected_vulnerable_imports.append(vulnerable_dependency)

    def __detect_vulnerable_installed_dependencies(self):
        """
        Check for vulnerable dependencies that have been installed and
        are used in the project to be analyzed.
        """
        # todo: check against DB with versions
        pass

    def __detect_vulnerable_functions(self):
        """
        Iterates through all files in all sub directories of the given path
        and performs the vulnerability analysis for vulnerable functions.
        """
        for root, dirs, files in os.walk(self.path):
            for file in files:
                # only analyze python files
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    self.detected_vulnerable_functions += self.__analyse_file_for_vulnerable_functions(file_path)

    # https://stackoverflow.com/questions/9008451/python-easy-way-to-read-all-import-statements-from-py-module
    def __get_imports(self, file_path):
        """
        Extract all import statements from the provided file including aliases.
        :param path: file to be analyzed
        :return: list of `ImportedModule`
        """
        # get the AST of the provided file
        with open(file_path) as file:
            root = ast.parse(file.read(), file_path)

        # extract import statements
        for node in ast.iter_child_nodes(root):
            if isinstance(node, ast.Import):
                module = ''
            elif isinstance(node, ast.ImportFrom):
                module = node.module
            else:
                continue

            for n in node.names:
                yield ImportedModule(module, n.name, n.asname, node.lineno, node.col_offset, None)

    def __get_functions_with_locations(self, file_path):
        """
        Extract all function of the provided file.
        :param file_path: path to the file to be analyzed
        :return: list of functions including their locations within the file:
        [(<function_name>, <line_number>, <offset_column>), ...]
        """
        with open(file_path) as file:
            tree = ast.parse(file.read(), file_path)
            return call_collector.get_func_calls(tree)

    def __analyse_file_for_vulnerable_functions(self, file_path):
        """
        Extracts all imports and functions of the provided file and
        checks them against the vulnerability database.
        :param file_path: file to be checked for vulnerabilities
        :return: list of detected `Vulnerability`
        """
        vulnerable_functions = VulnerabilityDB().get_all_vulnerable_functions()
        detected_vulnerable_functions = []

        # extract all called functions from file
        functions = self.__get_functions_with_locations(file_path)

        for function_with_location in functions:
            function_full_name = function_with_location[0]
            corresponding_import = None

            function_full_name not in vulnerable_functions

            if function_full_name not in vulnerable_functions:
                function_package = '.'.join(function_full_name.split('.')[:-1])

                # resolve aliases and imported function calls
                for imp in self.__get_imports(file_path):
                    corresponding_import = imp

                    if imp.alias is not None and imp.alias == function_package:
                        function_full_name = imp.module + '.' + imp.name + '.' + '.'.join(function_with_location[0].split('.')[1:])
                    elif imp.module is not None and function_package in imp.module + '.' + imp.name:
                        function_full_name = imp.module + '.' + function_with_location[0]

            vulnerability_description = None

            # collect detected vulnerabilities
            for vulnerability_name, vulnerability_info in vulnerable_functions.items():
                if vulnerability_name == function_full_name or function_full_name == vulnerability_name:
                    vulnerability_description = Vulnerability(
                        function_full_name,
                        file_path,
                        function_with_location[1],
                        function_with_location[2],
                        vulnerability_info['update_with'],
                        vulnerability_info['reason'],
                        corresponding_import,
                        function_with_location[2] + len(function_full_name),
                        None,
                        vulnerability_info['severity']
                    )

            if vulnerability_description:
                detected_vulnerable_functions.append(vulnerability_description)

        return detected_vulnerable_functions

    def __get_code_context_for_vulnerabilities(self):
        """
        Extracts the corresponding source code line for each vulnerability.
        This will be included into the report which makes fixing and tracking
        down vulnerabilities easier.
        """
        # get context for vulnerable functions
        for vulnerability in self.detected_vulnerable_functions:
            for line in fileinput.input(vulnerability.file, inplace=0):
                if fileinput and vulnerability.line == fileinput.filelineno():
                    vulnerability = vulnerability._replace(code=line)


    def replace_vulnerabilities(self):
        """
        Replaces detected vulnerabilities with the suggested replacement.
        """
        for vulnerability in self.detected_vulnerable_functions:
            if vulnerability.update is not None or vulnerability.update is not '':
                for line in fileinput.input(vulnerability.file, inplace=1):
                    if fileinput and vulnerability.line == fileinput.filelineno():
                        # replace vulnerable function and write back to file
                        print(line[:vulnerability.column] + vulnerability.update + line[vulnerability.end :])
                    else:
                        print(line, end=' ')

    def replace_vulnerabilities_in_ast(self):
        """
        todo
        """
        for root, dirs, files in os.walk(self.path):
            for file in files:
                # only analyze python files
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)

                    vulnerabilities_to_be_replaced = []

                    for detected_vulnerability in self.detected_vulnerable_functions:
                        if detected_vulnerability.file == file_path:
                            vulnerabilities_to_be_replaced.append(detected_vulnerability)

                    if len(vulnerabilities_to_be_replaced) > 0:
                        replaced_source = ''

                        with open(file_path) as py_file:
                            tree = ast.parse(py_file.read(), file_path)
                            replaced_source = call_collector.replace_func_calls(tree, vulnerabilities_to_be_replaced)

                        with open(file_path, 'w') as py_file:
                            py_file.write(replaced_source)


    def get_vulnerability_metrics(self):
        """
        Collect metrics of detected vulnerabilities and write them into a
        log file.
        The metrics will later be useful for the evaluation.
        """

        return {
            'total_vulnerable_functions': len(self.detected_vulnerable_functions),
            'total_vulnerable_imports': len(self.detected_vulnerable_imports),
            'vulnerable_imports': self.detected_vulnerable_imports,
            'vulnerable_functions': self.detected_vulnerable_functions
        }
