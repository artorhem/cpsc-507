from snakefood.util import iter_pyfiles, setup_logging, def_ignores
from snakefood.find import find_imports
import pip
import re, sys, os
import ast
from collections import namedtuple
import call_collector
import vulnerabilities
import fileinput


def get_dependencies(path):
    """
    Retrieves all dependencies from the projects located at `path`
    :param path: project path
    :return: list of dependencies
    """
    all_symnames = set()
    for fn in iter_pyfiles([path], None):
        all_symnames.update(x[0] for x in find_imports(fn, True, []) if not x[2])

    return all_symnames


def vulnerable_dependencies_in_path(path):
    vulnerable_dependencies = []        # warnings
    all_dependencies = get_dependencies(path)

    # static analysis: only look in code
    for dependency in all_dependencies:
        vulnerable_dependency = vulnerabilities.get_vulnerable_dependency(dependency.split('.')[0])
        if vulnerable_dependency:
            vulnerable_dependencies.append(vulnerable_dependency)

    # check installed dependencies
    # todo

    return vulnerable_dependencies



def vulnerability_analysis_in_path(path):
    """
    Iterates through all files in all sub directories of the given path
    and performs the vulnerability analysis.
    :param path: path to the directory which contains the files to be analyzed
    :return: list of detected `Vulnerability`
    """
    detected_vulnerabilities = []
    vulnerable_functions = vulnerabilities.get_all_vulnerable_functions()

    for root, dirs, files in os.walk(path):
        for file in files:
            # only analyze python files
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                detected_vulnerabilities += analyse_file_for_vulnerabilities(file_path, vulnerable_functions)

    return detected_vulnerabilities


# https://stackoverflow.com/questions/9008451/python-easy-way-to-read-all-import-statements-from-py-module
ImportedModule = namedtuple("ImportedModule", ["module", "name", "alias", "line", "column"])


def get_imports(file_path):
    """
    Extract all import statements from the provided file including aliases.
    :param path: file to be analyzed
    :return: list of `ImportedModule`
    """
    # get the AST of the provided file
    with open(file_path) as file:
        root = ast.parse(file.read(), file_path)

    # extract import statements
    for node in ast.iter_child_nodes(root):
        if isinstance(node, ast.Import):
            module = ''
        elif isinstance(node, ast.ImportFrom):
            module = node.module
        else:
            continue

        for n in node.names:
            yield ImportedModule(module, n.name, n.asname, node.lineno, node.col_offset)


def get_functions_with_locations(file_path):
    """
    Extract all function of the provided file.
    :param file_path: path to the file to be analyzed
    :return: list of functions including their locations within the file:
    [(<function_name>, <line_number>, <offset_column>), ...]
    """
    with open(file_path) as file:
        tree = ast.parse(file.read(), file_path)
        return call_collector.get_func_calls(tree)


Vulnerability = namedtuple("Vulnerability", ["name", "file", "line", "column", "update", "reason", "import_location"])

def analyse_file_for_vulnerabilities(file_path, vulnerabilities):
    """
    Extracts all imports and functions of the provided file and checks them against the
    vulnerability database.
    :param file_path: file to be checked for vulnerabilities
    :param vulnerabilities: collection of known vulnerabilities
    :return: list of detected `Vulnerability`
    """
    detected_vulnerable_functions = []

    # extract imports from file
    imports = get_imports(file_path)
    # extract all called functions from file
    functions = get_functions_with_locations(file_path)

    for function_with_location in functions:
        function_full_name = function_with_location[0]
        corresponding_import = None

        if function_full_name not in vulnerabilities:
            function_package = function_full_name.split('.')[:-1]

            # resolve aliases and imported function calls
            for imp in imports:
                corresponding_import = imp

                if imp.alias is not None and imp.alias == function_package:
                    function_full_name = imp.alias + '.' + function_with_location[0]
                elif imp.module is not None and imp.module + '.' + imp.name == function_package:
                    function_full_name = imp.module + '.' + imp.name + function_with_location[0]

        # collect detected vulnerabilities
        for vulnerability_name, vulnerability_info in vulnerabilities.iteritems():
            if vulnerability_name in function_full_name or function_full_name in vulnerability_name:

                detected_vulnerable_functions.append(Vulnerability(
                    function_full_name,
                    file_path,
                    function_with_location[1],
                    function_with_location[2],
                    vulnerability_info['update_with'],
                    vulnerability_info['reason'],
                    corresponding_import
                ))

    return detected_vulnerable_functions


def replace_vulnerabilities(detected_vulnerabilities):
    """
    Replaces detected vulnerabilities with the suggested replacement.
    :param detected_vulnerabilities: vulnerabilities to be replaced
    """
    for vulnerability in detected_vulnerabilities:
        if vulnerability.update is not None or vulnerability.update is not '':
            for line in fileinput.input(vulnerability.file, inplace=1):
                if fileinput and vulnerability.line == fileinput.filelineno():
                    # replace vulnerable function and write back to file
                    print line[:vulnerability.column] + vulnerability.update + line[vulnerability.column + len(vulnerability.update) - 1:]
                else:
                    print line ,

