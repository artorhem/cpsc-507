from snakefood.util import iter_pyfiles, setup_logging, def_ignores
from snakefood.find import find_imports
import pip
import re, sys, os
import ast
from collections import namedtuple
import call_collector
from vulnerabilities import VulnerabilityDB
import fileinput

ImportedModule = namedtuple("ImportedModule", ["module", "name", "alias", "line", "column", "code"])
Vulnerability = namedtuple("Vulnerability", ["name", "file", "line", "column", "update", "reason", "import_location", "code"])


class VulnerabilityAnalyzer:
    def __init__(self, path):
        """
        Constructor
        @param path: path to project to be analyzed
        """
        self.path = path
        self.detected_vulnerable_functions = []
        self.detected_vulnerable_imports = []
        self.detected_vulnerable_installed_dependencies = []
        self.outdated_dependencies = []

    def analyze(self):
        """
        Starts the analysis for vulnerable functions and
        vulnerable dependencies.
        """
        self.__detect_vulnerable_imports()
        self.__detect_vulnerable_functions()
        self.__get_code_context_for_vulnerabilities()
        self.__detect_vulnerable_installed_dependencies()
        self.__detect_outdated_dependencies()

    def __get_dependencies(self):
        """
        Retrieves all dependencies from the projects located at `path`
        :return: list of dependencies
        """
        all_symnames = set()
        for fn in iter_pyfiles([self.path], None):
            all_symnames.update(x[0] for x in find_imports(fn, True, []) if not x[2])

        return all_symnames

    def __detect_vulnerable_imports(self):
        """
        Check for vulnerable imports in source code.
        """
        all_dependencies = self.__get_dependencies()

        # static analysis: only look in code
        for dependency in all_dependencies:
            dependency_name = dependency.split('.')[0]
            vulnerable_dependency = VulnerabilityDB().get_vulnerable_dependency(dependency_name)
            vulnerable_dependency['name'] = dependency_name
            if vulnerable_dependency:
                self.detected_vulnerable_imports.append(vulnerable_dependency)

    def __detect_vulnerable_installed_dependencies(self):
        """
        Check for vulnerable dependencies that have been installed and
        are used in the project to be analyzed.
        """
        # todo: check against DB with versions
        pass

    def __detect_vulnerable_functions(self):
        """
        Iterates through all files in all sub directories of the given path
        and performs the vulnerability analysis for vulnerable functions.
        """
        for root, dirs, files in os.walk(self.path):
            for file in files:
                # only analyze python files
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    self.detected_vulnerable_functions += self.__analyse_file_for_vulnerable_functions(file_path)

    # https://stackoverflow.com/questions/9008451/python-easy-way-to-read-all-import-statements-from-py-module
    def __get_imports(self, file_path):
        """
        Extract all import statements from the provided file including aliases.
        :param path: file to be analyzed
        :return: list of `ImportedModule`
        """
        # get the AST of the provided file
        with open(file_path) as file:
            root = ast.parse(file.read(), file_path)

        # extract import statements
        for node in ast.iter_child_nodes(root):
            if isinstance(node, ast.Import):
                module = ''
            elif isinstance(node, ast.ImportFrom):
                module = node.module
            else:
                continue

            for n in node.names:
                yield ImportedModule(module, n.name, n.asname, node.lineno, node.col_offset, None)

    def __get_functions_with_locations(self, file_path):
        """
        Extract all function of the provided file.
        :param file_path: path to the file to be analyzed
        :return: list of functions including their locations within the file:
        [(<function_name>, <line_number>, <offset_column>), ...]
        """
        with open(file_path) as file:
            tree = ast.parse(file.read(), file_path)
            return call_collector.get_func_calls(tree)

    def __analyse_file_for_vulnerable_functions(self, file_path):
        """
        Extracts all imports and functions of the provided file and
        checks them against the vulnerability database.
        :param file_path: file to be checked for vulnerabilities
        :return: list of detected `Vulnerability`
        """
        vulnerable_functions = VulnerabilityDB().get_all_vulnerable_functions()
        detected_vulnerable_functions = []

        # extract imports from file
        imports = self.__get_imports(file_path)
        # extract all called functions from file
        functions = self.__get_functions_with_locations(file_path)

        for function_with_location in functions:
            function_full_name = function_with_location[0]
            corresponding_import = None

            if function_full_name not in vulnerable_functions:
                function_package = function_full_name.split('.')[:-1]

                # resolve aliases and imported function calls
                for imp in imports:
                    corresponding_import = imp

                    if imp.alias is not None and imp.alias == function_package:
                        function_full_name = imp.alias + '.' + function_with_location[0]
                    elif imp.module is not None and imp.module + '.' + imp.name == function_package:
                        function_full_name = imp.module + '.' + imp.name + function_with_location[0]

            # collect detected vulnerabilities
            for vulnerability_name, vulnerability_info in vulnerable_functions.iteritems():
                if vulnerability_name in function_full_name or function_full_name in vulnerability_name:

                    detected_vulnerable_functions.append(Vulnerability(
                        function_full_name,
                        file_path,
                        function_with_location[1],
                        function_with_location[2],
                        vulnerability_info['update_with'],
                        vulnerability_info['reason'],
                        corresponding_import,
                        None
                    ))

        return detected_vulnerable_functions

    def __get_code_context_for_vulnerabilities(self):
        """
        Extracts the corresponding source code line for each vulnerability.
        This will be included into the report which makes fixing and tracking
        down vulnerabilities easier.
        """
        # get context for vulnerable functions
        for vulnerability in self.detected_vulnerable_functions:
            for line in fileinput.input(vulnerability.file, inplace=0):
                if fileinput and vulnerability.line == fileinput.filelineno():
                    vulnerability.code = line

                # get context for vulnerable imports
                for imp in self.detected_vulnerable_imports:
                    if fileinput and imp.line == fileinput.filelineno():
                        imp.code = line


    def replace_vulnerabilities(self):
        """
        Replaces detected vulnerabilities with the suggested replacement.
        """
        for vulnerability in self.detected_vulnerable_functions:
            if vulnerability.update is not None or vulnerability.update is not '':
                for line in fileinput.input(vulnerability.file, inplace=1):
                    if fileinput and vulnerability.line == fileinput.filelineno():
                        # replace vulnerable function and write back to file
                        print line[:vulnerability.column] + vulnerability.update + line[vulnerability.column + len(vulnerability.update) - 1:]
                    else:
                        print line ,

